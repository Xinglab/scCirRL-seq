import argparse
import os
import sys
import pysam as ps
from datetime import datetime

from .__init__ import __version__
from .__init__ import __program__
from .__init__ import __cmd__

from .parameter import scrl_para_class, _bc_max_ed, _umi_max_ed, _bc_len, _umi_len, _five_ada
from .utils import err_log_format_time, start_time, err_log_end_time
from .seq_utils import collect_ref_barcodes, collect_mp_fetch_set
from .collect_candidate_bc import collect_cand_ref_bc
from .assign_bc import assign_ref_bc
from .parse_quant_file import collect_read_to_trans, collect_trans_to_gene
from .scCriRL_make_expression_matrix import make_10X_matrix


def parser_argv():
    # parse command line arguments
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description="{}: cell barocoding calling using only single-cell long-read data".format(__program__))
    parser.add_argument('long_bam', metavar='long.sorted.bam', type=str, help='Sorted single-cell long-read bam file')
    # parser.add_argument('updated_gtf', metavar='updated.gtf', type=str, help='Updated GTF annotation file, generated by ESPRESSO')
    # parser.add_argument('cmpt_tsv', metavar='read_isoform_compatible.tsv', type=str, help='TSV frile for compatible isoforms of each long read, generated by ESPRESSO')
    parser.add_argument('out_dir', metavar='out_dir', type=str, help='Output folder for for all result files')
    parser.add_argument('-v', '--version', action='version', version=__program__ + ' ' + __version__)

    input_parser = parser.add_argument_group('input files')
    input_parser.add_argument('-g', '--anno-gtf', type=str, default='', help='Annotation GTF file')
    input_parser.add_argument('-t', '--updated-gtf', type=str, default='', help='Updated GTF annotation file, generated by Bambu/ESPRESSO')
    input_parser.add_argument('-m', '--cmpt-tsv', type=str, default='', help='TSV frile for compatible isoforms of each long read, generated by Bambu/ESPRESSO')
    # input_parser.add_argument('-f', '--cate', type=str, default='all', help='Only use reads that are classified as specified category(FSM/ISM/NIC/NNC/NCD/single-exon), seperated by comma for multiple categories, effective only when cmpt-tsv is provided')
    # input_parser.add_argument('-i', '--isoquant', action='store_true', default=False, help='Input quantification files (updated_gtf/comp_tsv) are from ISOQUANT, from ESPRESSO by default')
    input_parser.add_argument('-l', '--bc-list', type=str, default='', help='Reference cell barcode list.\n'+ \
                                 f'{__program__} will directly use it to guide the barcode calling if the reference barcodes are provided.')
    
    barcode_umi_par = parser.add_argument_group('barcode and UMI related options')
    barcode_umi_par.add_argument('-b', '--bc-len', type=int, default=_bc_len, help='Barcode length')
    barcode_umi_par.add_argument('-e', '--bc-ed', type=int, default=_bc_max_ed, help='Max allowed edit distance for barcode to reference barcode')
    barcode_umi_par.add_argument('-u', '--umi-len', type=int, default=_umi_len, help='UMI length')
    barcode_umi_par.add_argument('-d', '--umi-ed', type=int, default=_umi_max_ed, help='Max allowed edit distance for UMIs')
    barcode_umi_par.add_argument('-5', '--five-ada', type=str, default=_five_ada, help='5\' adapter sequence')
    barcode_umi_par.add_argument('-c', '--cell-count', type=int, default=-1, help='Number of cells to keep. By default, NanoHunter will automatically detect cell count based on knee point. If provided, only top N cells will be kept')
    barcode_umi_par.add_argument('-s', '--skip-chimeric', action='store_true', default=False, help='Skip read if it is chimeric, i.e., maps to multiple genomic regions')
    barcode_umi_par.add_argument('-p', '--only-primary', action='store_true', default=False, help='Only use primary alignments, ignore any supplementary alignments (for chimeric reads)')
    return parser.parse_args()

def set_scrl_para(args, scrl_para):
    scrl_para.long_bam = args.long_bam
    scrl_para.updated_gtf = args.updated_gtf
    scrl_para.anno_gtf = args.anno_gtf
    scrl_para.cmpt_tsv = args.cmpt_tsv
    # scrl_para.cate = scrl_para.cate if args.cate.upper() == 'ALL' else args.cate.upper().split(',')
    # scrl_para.isoquant = args.isoquant
    scrl_para.bc_list = args.bc_list
    scrl_para.bc_len = args.bc_len
    scrl_para.bc_max_ed = args.bc_ed
    scrl_para.umi_len = args.umi_len
    scrl_para.umi_max_ed = args.umi_ed
    scrl_para.cell_count = args.cell_count
    scrl_para.five_ada = args.five_ada
    scrl_para.five_max_ed = int(len(scrl_para.five_ada) * 0.3)
    scrl_para.skip_chimeric = args.skip_chimeric
    scrl_para.only_primary = args.only_primary
    scrl_para.out_dir = args.out_dir
    if not os.path.exists(scrl_para.out_dir):
        os.makedirs(scrl_para.out_dir)
    scrl_para.high_qual_bu_fn = os.path.join(scrl_para.out_dir, 'high_qual_bc.rank.tsv')
    scrl_para.out_ref_bc_fn = os.path.join(scrl_para.out_dir, 'ref_bc.tsv')
    scrl_para.out_bu_fn = os.path.join(scrl_para.out_dir, 'bc_umi.tsv')
    scrl_para.out_bu_bam = os.path.join(scrl_para.out_dir, 'bc_umi.sorted.bam')
    scrl_para.out_mtx_dir = os.path.join(scrl_para.out_dir, 'expression_matrix')
    now = datetime.now()
    scrl_para.log_fn = os.path.join(scrl_para.out_dir, 'scCirRL_{}_{}.log'.format(os.path.basename(scrl_para.long_bam), now.strftime("%Y%m%d_%H%M%S")))
    
    return scrl_para

def scCirRL_self(scrl_para):
    err_log_format_time(scrl_para.log_fn, 'CMD', '{}'.format(__cmd__))

    if not os.path.exists(scrl_para.long_bam + '.bai'):
        err_log_format_time(scrl_para.log_fn, str='BAM index file not found: {}.bai'.format(scrl_para.long_bam))
        err_log_format_time(scrl_para.log_fn, str='Building BAM index for {}'.format(scrl_para.long_bam))
        try:
            ps.index(scrl_para.long_bam)
            err_log_format_time(scrl_para.log_fn, str='Building index done')
        except:
            err_log_format_time(scrl_para.log_fn, 'ERROR', 'Can not build index for: {}\nSorted BAM is required, please double-check your BAM file'.format(scrl_para.long_bam))
            return
    mp_fetch_set, n_total_reads = collect_mp_fetch_set(scrl_para)

    # 1st round: collect perfect BC & UMI, to use as reference BC
    # all bc in cand_ref_bcs will be used as reference bc
    # then, choose one best matched bc from cand_ref_bcs for each other read
    if scrl_para.bc_list:
        scrl_ref_bcs = collect_ref_barcodes(scrl_para)
    else:
        scrl_ref_bcs = collect_cand_ref_bc(scrl_para)
        if len(scrl_ref_bcs) == 0:
            err_log_format_time(scrl_para.log_fn, str='No candidate cell barcode detected. Program exited early.')
            return
        with open(scrl_para.out_ref_bc_fn, 'w') as fp:
            for bc in scrl_ref_bcs:
                fp.write('{}\n'.format(bc))
    scrl_cand_ref_bc_seq = ('N' * (scrl_para.bc_max_ed+1)).join(scrl_ref_bcs)

    # 2nd round: search for exactly matched and uniquely matched BC
    trans_to_gene_id_name = collect_trans_to_gene(scrl_para)
    read_to_trans, read_to_cate = collect_read_to_trans(trans_to_gene_id_name, scrl_para)
    assign_ref_bc(mp_fetch_set, n_total_reads, scrl_ref_bcs, scrl_cand_ref_bc_seq, trans_to_gene_id_name, read_to_trans, read_to_cate, scrl_para)

    # 3rd round: quantification, generate mtx file
    # make_10X_matrix(None, None, scrl_para.out_bu_fn, scrl_para.out_mtx_dir)
    make_10X_matrix(None, None, scrl_para)

def main():
    start_time()
    args = parser_argv()
    scrl_para = scrl_para_class()
    set_scrl_para(args, scrl_para)
    scCirRL_self(scrl_para)
    err_log_end_time(scrl_para.log_fn)

if __name__ == '__main__':
    main()
