import argparse
import os
import sys
import pysam as ps
from datetime import datetime

from .__init__ import __version__
from .__init__ import __program__
from .__init__ import __cmd__

from .parameter import nanohunter_para, _bc_max_ed, _umi_max_ed, _bc_len, _umi_len, _max_clip_len, _five_ada
from .utils import err_log_format_time, err_fatal_format_time
from .seq_utils import collect_ref_barcodes, collect_mp_fetch_set
from .collect_candidate_bc import collect_cand_ref_bc
from .assign_bc import assign_ref_bc
from .parse_quant_file import collect_read_to_trans, collect_trans_to_gene
from .nh_make_expression_matrix import make_10X_matrix


def parser_argv():
    # parse command line arguments
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description="{}: cell barocoding calling using only single-cell long-read data".format(__program__))
    parser.add_argument('long_bam', metavar='long.sorted.bam', type=str, help='Sorted single-cell long-read bam file')
    # parser.add_argument('updated_gtf', metavar='updated.gtf', type=str, help='Updated GTF annotation file, generated by ESPRESSO/ISOQUANT')
    # parser.add_argument('cmpt_tsv', metavar='read_isoform_compatible.tsv', type=str, help='TSV frile for compatible isoforms of each long read, generated by ESPRESSO/ISOQUANT')
    parser.add_argument('out_dir', metavar='out_dir', type=str, help='Output folder for for all result files')
    parser.add_argument('-v', '--version', action='version', version=__program__ + ' ' + __version__)

    input_parser = parser.add_argument_group('input files')
    input_parser.add_argument('-g', '--anno-gtf', type=str, default='', help='Annotation GTF file')
    input_parser.add_argument('-p', '--updated-gtf', type=str, default='', help='Updated GTF annotation file, generated by ESPRESSO/ISOQUANT')
    input_parser.add_argument('-m', '--cmpt-tsv', type=str, default='', help='TSV frile for compatible isoforms of each long read, generated by ESPRESSO/ISOQUANT')
    input_parser.add_argument('-i', '--isoquant', action='store_true', default=False, help='Input quantification files (updated_gtf/comp_tsv) are from ISOQUANT, from ESPRESSO by default')
    input_parser.add_argument('-l', '--bc-list', type=str, default='', help='Reference cell barcode list.\n'+ \
                                 f'{__program__} will directly use it to guide the barcode calling if the reference barcodes are provided.')
    
    barcode_umi_par = parser.add_argument_group('barcode and UMI related options')
    barcode_umi_par.add_argument('-b', '--bc-len', type=int, default=_bc_len, help='Barcode length')
    barcode_umi_par.add_argument('-e', '--bc-ed', type=int, default=_bc_max_ed, help='Max allowed edit distance for barcode to reference barcode')
    barcode_umi_par.add_argument('-u', '--umi-len', type=int, default=_umi_len, help='UMI length')
    barcode_umi_par.add_argument('-f', '--umi-ed', type=int, default=_umi_max_ed, help='Max allowed edit distance for UMIs')
    barcode_umi_par.add_argument('-5', '--five-ada', type=str, default=_five_ada, help='5\' adapter sequence')
    barcode_umi_par.add_argument('-c', '--max-clip-len', type=int, default=_max_clip_len, help='Max allowed clipped length')
    barcode_umi_par.add_argument('-x', '--all-alignments', action='store_true', default=False, help='Use all alignments of each read, instead of only the primary alignment' +
                                                                                                    'If set as TRUE, \'-c/--max-clip-len\' will not be used.' )
    return parser.parse_args()

def set_nh_para(args, nh_para):
    nh_para.long_bam = args.long_bam
    nh_para.updated_gtf = args.updated_gtf
    nh_para.anno_gtf = args.anno_gtf
    nh_para.cmpt_tsv = args.cmpt_tsv
    nh_para.isoquant = args.isoquant
    nh_para.bc_list = args.bc_list
    nh_para.bc_len = args.bc_len
    nh_para.bc_max_ed = args.bc_ed
    nh_para.umi_len = args.umi_len
    nh_para.umi_max_ed = args.umi_ed
    nh_para.max_clip_len = args.max_clip_len
    nh_para.five_ada = args.five_ada
    nh_para.five_max_ed = int(len(nh_para.five_ada) * 0.3)
    nh_para.all_alignments = args.all_alignments
    nh_para.out_dir = args.out_dir
    if not os.path.exists(nh_para.out_dir):
        os.makedirs(nh_para.out_dir)
    nh_para.high_qual_bu_fn = os.path.join(nh_para.out_dir, 'high_qual_bc_umi.rank.tsv')
    nh_para.out_ref_bc_fn = os.path.join(nh_para.out_dir, 'ref_bc.tsv')
    nh_para.out_bu_fn = os.path.join(nh_para.out_dir, 'bc_umi.tsv')
    nh_para.out_bu_bam = os.path.join(nh_para.out_dir, 'bc_umi.bam')
    nh_para.out_mtx_dir = os.path.join(nh_para.out_dir, 'expression_matrix')
    now = datetime.now()
    nh_para.log_fn = os.path.join(nh_para.out_dir, 'nanohunter_{}_{}.log'.format(os.path.basename(nh_para.long_bam), now.strftime("%Y%m%d_%H%M%S")))
    
    return nh_para

def nanohunter_self(nh_para):
    err_log_format_time(nh_para.log_fn, 'CMD',  '{}'.format(__cmd__))
    # bam_fn = args.long_bam
    # updated_gtf = args.updated_gtf
    # anno_gtf = args.anno_gtf
    # cmpt_tsv = args.cmpt_tsv
    # is_isoquant = args.isoquant
    # bc_list, bc_len, umi_len = args.bc_list, args.bc_len, args.umi_len
    # bc_max_ed, umi_max_ed = args.bc_ed, args.umi_ed
    # max_clip_len, use_all_alignments = args.max_clip_len, args.all_alignments

    if not os.path.exists(nh_para.long_bam + '.bai'):
        err_log_format_time(nh_para.log_fn, __name__, 'BAM index file not found: {}.bai'.format(nh_para.long_bam))
        err_log_format_time(nh_para.log_fn, __name__, 'Building BAM index for {}'.format(nh_para.long_bam))
        try:
            ps.index(nh_para.long_bam)
            err_log_format_time(nh_para.log_fn, __name__, 'Building index done')
        except:
            err_fatal_format_time(__name__, 'Can not build index for: {}\nPlease double-check your BAM file'.format(nh_para.long_bam))
    mp_fetch_set, n_total_reads = collect_mp_fetch_set(nh_para)

    # 1st round: collect perfect BC & UMI, to use as reference BC
    # all bc in cand_ref_bcs will be used as reference bc
    # then, choose one best matched bc from cand_ref_bcs for each other read
    if nh_para.bc_list:
        nh_ref_bcs = collect_ref_barcodes(nh_para)
    else:
        nh_ref_bcs = collect_cand_ref_bc(nh_para)
        if len(nh_ref_bcs) == 0:
            err_log_format_time(nh_para.log_fn, __name__, 'No candidate cell barcode detected. Program exited early.')
            return
        with open(nh_para.out_ref_bc_fn, 'w') as fp:
            for bc in nh_ref_bcs:
                fp.write('{}\n'.format(bc))
    nh_cand_ref_bc_seq = ('N' * (nh_para.bc_max_ed+1)).join(nh_ref_bcs)

    # 2nd round: search for exactly matched and uniquely matched BC
    trans_to_gene_id_name = collect_trans_to_gene(nh_para)
    read_to_trans = collect_read_to_trans(trans_to_gene_id_name, nh_para)
    assign_ref_bc(mp_fetch_set, n_total_reads, nh_ref_bcs, nh_cand_ref_bc_seq, trans_to_gene_id_name, read_to_trans, nh_para)

    # 3rd round: quantification, generate mtx file
    make_10X_matrix(None, None, nh_para.out_bu_fn, nh_para.out_mtx_dir)

def main():
    args = parser_argv()
    nh_para = nanohunter_para()
    set_nh_para(args, nh_para)
    nanohunter_self(nh_para)

if __name__ == '__main__':
    main()
