import argparse
import os
import sys
import pysam as ps

from .__init__ import __version__
from .__init__ import __program__
from .__init__ import __cmd__

from .utils import err_format_time, err_fatal_format_time
from .seq_utils import _bc_max_ed, _umi_max_ed, _bc_len, _umi_len, get_ref_barcodes, get_mp_fetch_set
from .collect_candidate_bc import collect_cand_ref_bc
from .assign_bc import assign_ref_bc
from .parse_quant_file import get_read_to_trans, get_trans_to_gene
from .nh_make_expression_matrix import make_10X_matrix


def parser_argv():
    # parse command line arguments
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description="{}: cell barocoding calling using only single-cell long-read data".format(__program__))
    parser.add_argument('long_bam', metavar='long.sorted.bam', type=str, help='Sorted single-cell long-read bam file')
    parser.add_argument('updated_gtf', metavar='updated.gtf', type=str, help='Updated GTF annotation file, generated by ESPRESSO/ISOQUANT')
    parser.add_argument('cmpt_tsv', metavar='read_isoform_compatible.tsv', type=str, help='TSV frile for compatible isoforms of each long read, generated by ESPRESSO/ISOQUANT')
    parser.add_argument('out_dir', metavar='out_dir', type=str, help='Output folder for for all result files')

    barcode_umi_par = parser.add_argument_group('barcode and UMI options')
    barcode_umi_par.add_argument('-l', '--bc-list', type=str, default='', help='Reference cell barcode list.\n'+ \
                                 f'{__program__} will directly use it to guide the barcode calling if the reference barcodes are provided.')
    barcode_umi_par.add_argument('-b', '--bc-len', type=int, default=_bc_len, help='Barcode length')
    barcode_umi_par.add_argument('-e', '--bc-ed', type=int, default=_bc_max_ed, help='Max allowed edit distance for barcode to reference barcode')
    barcode_umi_par.add_argument('-u', '--umi-len', type=int, default=_umi_len, help='UMI length')
    barcode_umi_par.add_argument('-f', '--umi-ed', type=int, default=_umi_max_ed, help='Max allowed edit distance for UMIs')

    general_par = parser.add_argument_group('general options')
    general_par.add_argument('-i', '--isoquant', action='store_true', default=False, help='Input quantification files (updated_gtf/comp_tsv) are from ISOQUANT, from ESPRESSO by default')
    general_par.add_argument('-g', '--anno-gtf', type=str, default='', help='Annotation GTF file, for ')
    general_par.add_argument('-c', '--ncpu', type=int, default=1, help='Number of CPU to use')
    general_par.add_argument('-v', '--version', action='version', version=__program__ + ' ' + __version__)

    # quant_par = parser.add_argument_group('quantification result options')
    # quant_par.add_argument('-m', '--tsv-compt', type=str, default='', help='Read-isoform compatible file, generated from ESPRESSO')

    return parser.parse_args()


def bc_umi_calling(args, high_qual_bu_fn, out_ref_bc_fn, out_bu_fn, out_bu_bam, out_mtx_dir):
    bam_fn = args.long_bam
    updated_gtf = args.updated_gtf
    anno_gtf = args.anno_gtf
    cmpt_tsv = args.cmpt_tsv
    is_isoquant = args.isoquant
    ncpu = args.ncpu
    bc_list, bc_len, umi_len = args.bc_list, args.bc_len, args.umi_len
    bc_max_ed, umi_max_ed = args.bc_ed, args.umi_ed

    if not os.path.exists(bam_fn + '.bai'):
        try:
            ps.index(bam_fn)
        except:
            err_fatal_format_time(__name__, 'Not sorted BAM file: {}'.format(bam_fn))
    mp_fetch_set = get_mp_fetch_set(bam_fn)

    # 1st round: collect perfect BC & UMI, to use as reference BC
    # all bc in cand_ref_bcs will be used as reference bc
    # then, choose one best matched bc from cand_ref_bcs for each other read
    if bc_list:
        nh_ref_bcs = get_ref_barcodes(bc_list, bc_len)
    else:
        nh_ref_bcs = collect_cand_ref_bc(mp_fetch_set, bc_len, bam_fn, high_qual_bu_fn, ncpu)
        if len(nh_ref_bcs) == 0:
            err_format_time(__name__, 'No candidate reference barcode detected. Program exited early.')
            return
        with open(out_ref_bc_fn, 'w') as fp:
            for bc in nh_ref_bcs:
                fp.write('{}\n'.format(bc))
    nh_cand_ref_bc_seq = ('N' * (_bc_max_ed+1)).join(nh_ref_bcs)

    # 2nd round: search for exactly matched and uniquely matched BC
    trans_to_gene_id_name = get_trans_to_gene(updated_gtf, anno_gtf)
    read_to_trans = None if cmpt_tsv == '' else get_read_to_trans(cmpt_tsv, trans_to_gene_id_name, is_isoquant)
    assign_ref_bc(mp_fetch_set, nh_ref_bcs, nh_cand_ref_bc_seq, bc_len, bc_max_ed, umi_len, bam_fn, read_to_trans, trans_to_gene_id_name, out_bu_fn, out_bu_bam, ncpu)

    # 3rd round: quantification, generate mtx file
    make_10X_matrix(out_bu_fn, None, out_mtx_dir)


def nanohunter_self(args):
    out_dir = os.path.dirname(os.path.abspath(args.out_dir))
    if not os.path.exists(out_dir):
        os.makedirs(out_dir)
    high_qual_bu_fn = args.out_dir + '/high_qual_bc_umi.rank.tsv'
    out_ref_bc_fn = args.out_dir + '/ref_bc.tsv'
    out_bu_fn = args.out_dir + '/bc_umi.tsv'
    out_bu_bam = args.out_dir + '/bc_umi.bam'
    out_mtx_dir = args.out_dir + '/expression_matrix'

    err_format_time('CMD',  '{}'.format(__cmd__))
    bc_umi_calling(args, high_qual_bu_fn, out_ref_bc_fn, out_bu_fn, out_bu_bam, out_mtx_dir)


def main():
    args = parser_argv()
    nanohunter_self(args)


if __name__ == '__main__':
    main()
